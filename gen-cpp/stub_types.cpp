/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "stub_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




WfsError::~WfsError() noexcept {
}

WfsError::WfsError() noexcept
   : code(0),
     info() {
}

void WfsError::__set_code(const int32_t val) {
  this->code = val;
__isset.code = true;
}

void WfsError::__set_info(const std::string& val) {
  this->info = val;
__isset.info = true;
}
std::ostream& operator<<(std::ostream& out, const WfsError& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WfsError::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->info);
          this->__isset.info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WfsError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WfsError");

  if (this->__isset.code) {
    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->code);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.info) {
    xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->info);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WfsError &a, WfsError &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.info, b.info);
  swap(a.__isset, b.__isset);
}

bool WfsError::operator==(const WfsError & rhs) const
{
  if (__isset.code != rhs.__isset.code)
    return false;
  else if (__isset.code && !(code == rhs.code))
    return false;
  if (__isset.info != rhs.__isset.info)
    return false;
  else if (__isset.info && !(info == rhs.info))
    return false;
  return true;
}

WfsError::WfsError(const WfsError& other0) {
  code = other0.code;
  info = other0.info;
  __isset = other0.__isset;
}
WfsError& WfsError::operator=(const WfsError& other1) {
  code = other1.code;
  info = other1.info;
  __isset = other1.__isset;
  return *this;
}
void WfsError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WfsError(";
  out << "code="; (__isset.code ? (out << to_string(code)) : (out << "<null>"));
  out << ", " << "info="; (__isset.info ? (out << to_string(info)) : (out << "<null>"));
  out << ")";
}


WfsAck::~WfsAck() noexcept {
}

WfsAck::WfsAck() noexcept
   : ok(0) {
}

void WfsAck::__set_ok(const bool val) {
  this->ok = val;
}

void WfsAck::__set_error(const WfsError& val) {
  this->error = val;
__isset.error = true;
}
std::ostream& operator<<(std::ostream& out, const WfsAck& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WfsAck::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ok = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ok);
          isset_ok = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ok)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WfsAck::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WfsAck");

  xfer += oprot->writeFieldBegin("ok", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->ok);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WfsAck &a, WfsAck &b) {
  using ::std::swap;
  swap(a.ok, b.ok);
  swap(a.error, b.error);
  swap(a.__isset, b.__isset);
}

bool WfsAck::operator==(const WfsAck & rhs) const
{
  if (!(ok == rhs.ok))
    return false;
  if (__isset.error != rhs.__isset.error)
    return false;
  else if (__isset.error && !(error == rhs.error))
    return false;
  return true;
}

WfsAck::WfsAck(const WfsAck& other2) {
  ok = other2.ok;
  error = other2.error;
  __isset = other2.__isset;
}
WfsAck& WfsAck::operator=(const WfsAck& other3) {
  ok = other3.ok;
  error = other3.error;
  __isset = other3.__isset;
  return *this;
}
void WfsAck::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WfsAck(";
  out << "ok=" << to_string(ok);
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ")";
}


WfsReq::~WfsReq() noexcept {
}

WfsReq::WfsReq() noexcept
   : path() {
}

void WfsReq::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}
std::ostream& operator<<(std::ostream& out, const WfsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WfsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WfsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WfsReq");

  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WfsReq &a, WfsReq &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

bool WfsReq::operator==(const WfsReq & rhs) const
{
  if (__isset.path != rhs.__isset.path)
    return false;
  else if (__isset.path && !(path == rhs.path))
    return false;
  return true;
}

WfsReq::WfsReq(const WfsReq& other4) {
  path = other4.path;
  __isset = other4.__isset;
}
WfsReq& WfsReq::operator=(const WfsReq& other5) {
  path = other5.path;
  __isset = other5.__isset;
  return *this;
}
void WfsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WfsReq(";
  out << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


WfsAuth::~WfsAuth() noexcept {
}

WfsAuth::WfsAuth() noexcept
   : name(),
     pwd() {
}

void WfsAuth::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void WfsAuth::__set_pwd(const std::string& val) {
  this->pwd = val;
__isset.pwd = true;
}
std::ostream& operator<<(std::ostream& out, const WfsAuth& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WfsAuth::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pwd);
          this->__isset.pwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WfsAuth::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WfsAuth");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pwd) {
    xfer += oprot->writeFieldBegin("pwd", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->pwd);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WfsAuth &a, WfsAuth &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.pwd, b.pwd);
  swap(a.__isset, b.__isset);
}

bool WfsAuth::operator==(const WfsAuth & rhs) const
{
  if (__isset.name != rhs.__isset.name)
    return false;
  else if (__isset.name && !(name == rhs.name))
    return false;
  if (__isset.pwd != rhs.__isset.pwd)
    return false;
  else if (__isset.pwd && !(pwd == rhs.pwd))
    return false;
  return true;
}

WfsAuth::WfsAuth(const WfsAuth& other6) {
  name = other6.name;
  pwd = other6.pwd;
  __isset = other6.__isset;
}
WfsAuth& WfsAuth::operator=(const WfsAuth& other7) {
  name = other7.name;
  pwd = other7.pwd;
  __isset = other7.__isset;
  return *this;
}
void WfsAuth::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WfsAuth(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "pwd="; (__isset.pwd ? (out << to_string(pwd)) : (out << "<null>"));
  out << ")";
}


WfsData::~WfsData() noexcept {
}

WfsData::WfsData() noexcept
   : data() {
}

void WfsData::__set_data(const std::string& val) {
  this->data = val;
__isset.data = true;
}
std::ostream& operator<<(std::ostream& out, const WfsData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WfsData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WfsData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WfsData");

  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->data);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WfsData &a, WfsData &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

bool WfsData::operator==(const WfsData & rhs) const
{
  if (__isset.data != rhs.__isset.data)
    return false;
  else if (__isset.data && !(data == rhs.data))
    return false;
  return true;
}

WfsData::WfsData(const WfsData& other8) {
  data = other8.data;
  __isset = other8.__isset;
}
WfsData& WfsData::operator=(const WfsData& other9) {
  data = other9.data;
  __isset = other9.__isset;
  return *this;
}
void WfsData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WfsData(";
  out << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ")";
}


WfsFile::~WfsFile() noexcept {
}

WfsFile::WfsFile() noexcept
   : data(),
     name(),
     compress(0) {
}

void WfsFile::__set_data(const std::string& val) {
  this->data = val;
}

void WfsFile::__set_name(const std::string& val) {
  this->name = val;
}

void WfsFile::__set_compress(const int8_t val) {
  this->compress = val;
__isset.compress = true;
}
std::ostream& operator<<(std::ostream& out, const WfsFile& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t WfsFile::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data = false;
  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          isset_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->compress);
          this->__isset.compress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WfsFile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WfsFile");

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.compress) {
    xfer += oprot->writeFieldBegin("compress", ::apache::thrift::protocol::T_BYTE, 3);
    xfer += oprot->writeByte(this->compress);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WfsFile &a, WfsFile &b) {
  using ::std::swap;
  swap(a.data, b.data);
  swap(a.name, b.name);
  swap(a.compress, b.compress);
  swap(a.__isset, b.__isset);
}

bool WfsFile::operator==(const WfsFile & rhs) const
{
  if (!(data == rhs.data))
    return false;
  if (!(name == rhs.name))
    return false;
  if (__isset.compress != rhs.__isset.compress)
    return false;
  else if (__isset.compress && !(compress == rhs.compress))
    return false;
  return true;
}

WfsFile::WfsFile(const WfsFile& other10) {
  data = other10.data;
  name = other10.name;
  compress = other10.compress;
  __isset = other10.__isset;
}
WfsFile& WfsFile::operator=(const WfsFile& other11) {
  data = other11.data;
  name = other11.name;
  compress = other11.compress;
  __isset = other11.__isset;
  return *this;
}
void WfsFile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WfsFile(";
  out << "data=" << to_string(data);
  out << ", " << "name=" << to_string(name);
  out << ", " << "compress="; (__isset.compress ? (out << to_string(compress)) : (out << "<null>"));
  out << ")";
}


