/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "stub_types.h"
#include <thrift/c_glib/thrift.h>

enum _WfsErrorProperties
{
  PROP_WFS_ERROR_0,
  PROP_WFS_ERROR_CODE,
  PROP_WFS_ERROR_INFO
};

/* reads a wfs_error object */
static gint32
wfs_error_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsError * this_object = WFS_ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->info != NULL)
          {
            g_free(this_object->info);
            this_object->info = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->info, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_info = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_error_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsError * this_object = WFS_ERROR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsError", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_code == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->code, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_info == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "info", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->info, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_error_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  WfsError *self = WFS_ERROR (object);

  switch (property_id)
  {
    case PROP_WFS_ERROR_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_WFS_ERROR_INFO:
      if (self->info != NULL)
        g_free (self->info);
      self->info = g_value_dup_string (value);
      self->__isset_info = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_error_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  WfsError *self = WFS_ERROR (object);

  switch (property_id)
  {
    case PROP_WFS_ERROR_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_WFS_ERROR_INFO:
      g_value_set_string (value, self->info);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_error_instance_init (WfsError * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->info = NULL;
  object->__isset_info = FALSE;
}

static void 
wfs_error_finalize (GObject *object)
{
  WfsError *tobject = WFS_ERROR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->info != NULL)
  {
    g_free(tobject->info);
    tobject->info = NULL;
  }
}

static void
wfs_error_class_init (WfsErrorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_error_read;
  struct_class->write = wfs_error_write;

  gobject_class->finalize = wfs_error_finalize;
  gobject_class->get_property = wfs_error_get_property;
  gobject_class->set_property = wfs_error_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_ERROR_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_ERROR_INFO,
     g_param_spec_string ("info",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
wfs_error_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsErrorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_error_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsError),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_error_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsErrorType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsAckProperties
{
  PROP_WFS_ACK_0,
  PROP_WFS_ACK_OK,
  PROP_WFS_ACK_ERROR
};

/* reads a wfs_ack object */
static gint32
wfs_ack_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsAck * this_object = WFS_ACK(object);
  gboolean isset_ok = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->ok, error)) < 0)
            return -1;
          xfer += ret;
          isset_ok = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_error = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_ok)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
wfs_ack_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsAck * this_object = WFS_ACK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsAck", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ok", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->ok, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_error == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "error", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->error), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_ack_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  WfsAck *self = WFS_ACK (object);

  switch (property_id)
  {
    case PROP_WFS_ACK_OK:
      self->ok = g_value_get_boolean (value);
      break;

    case PROP_WFS_ACK_ERROR:
      if (self->error != NULL)
        g_object_unref (self->error);
      self->error = g_value_dup_object (value);
      self->__isset_error = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_ack_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  WfsAck *self = WFS_ACK (object);

  switch (property_id)
  {
    case PROP_WFS_ACK_OK:
      g_value_set_boolean (value, self->ok);
      break;

    case PROP_WFS_ACK_ERROR:
      g_value_set_object (value, self->error);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_ack_instance_init (WfsAck * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ok = 0;
  object->error = g_object_new (TYPE_WFS_ERROR, NULL);
  object->__isset_error = FALSE;
}

static void 
wfs_ack_finalize (GObject *object)
{
  WfsAck *tobject = WFS_ACK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error != NULL)
  {
    g_object_unref(tobject->error);
    tobject->error = NULL;
  }
}

static void
wfs_ack_class_init (WfsAckClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_ack_read;
  struct_class->write = wfs_ack_write;

  gobject_class->finalize = wfs_ack_finalize;
  gobject_class->get_property = wfs_ack_get_property;
  gobject_class->set_property = wfs_ack_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_ACK_OK,
     g_param_spec_boolean ("ok",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_ACK_ERROR,
     g_param_spec_object ("error",
                         NULL,
                         NULL,
                         TYPE_WFS_ERROR,
                         G_PARAM_READWRITE));
}

GType
wfs_ack_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsAckClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_ack_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsAck),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_ack_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsAckType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsReqProperties
{
  PROP_WFS_REQ_0,
  PROP_WFS_REQ_PATH
};

/* reads a wfs_req object */
static gint32
wfs_req_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsReq * this_object = WFS_REQ(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_req_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsReq * this_object = WFS_REQ(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsReq", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_path == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_req_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  WfsReq *self = WFS_REQ (object);

  switch (property_id)
  {
    case PROP_WFS_REQ_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_req_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  WfsReq *self = WFS_REQ (object);

  switch (property_id)
  {
    case PROP_WFS_REQ_PATH:
      g_value_set_string (value, self->path);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_req_instance_init (WfsReq * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
}

static void 
wfs_req_finalize (GObject *object)
{
  WfsReq *tobject = WFS_REQ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
wfs_req_class_init (WfsReqClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_req_read;
  struct_class->write = wfs_req_write;

  gobject_class->finalize = wfs_req_finalize;
  gobject_class->get_property = wfs_req_get_property;
  gobject_class->set_property = wfs_req_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_REQ_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
wfs_req_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsReqClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_req_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsReq),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_req_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsReqType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsAuthProperties
{
  PROP_WFS_AUTH_0,
  PROP_WFS_AUTH_NAME,
  PROP_WFS_AUTH_PWD
};

/* reads a wfs_auth object */
static gint32
wfs_auth_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsAuth * this_object = WFS_AUTH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pwd != NULL)
          {
            g_free(this_object->pwd);
            this_object->pwd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->pwd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pwd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_auth_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsAuth * this_object = WFS_AUTH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsAuth", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_pwd == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pwd", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->pwd, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_auth_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  WfsAuth *self = WFS_AUTH (object);

  switch (property_id)
  {
    case PROP_WFS_AUTH_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_WFS_AUTH_PWD:
      if (self->pwd != NULL)
        g_free (self->pwd);
      self->pwd = g_value_dup_string (value);
      self->__isset_pwd = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_auth_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  WfsAuth *self = WFS_AUTH (object);

  switch (property_id)
  {
    case PROP_WFS_AUTH_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_WFS_AUTH_PWD:
      g_value_set_string (value, self->pwd);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_auth_instance_init (WfsAuth * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->pwd = NULL;
  object->__isset_pwd = FALSE;
}

static void 
wfs_auth_finalize (GObject *object)
{
  WfsAuth *tobject = WFS_AUTH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->pwd != NULL)
  {
    g_free(tobject->pwd);
    tobject->pwd = NULL;
  }
}

static void
wfs_auth_class_init (WfsAuthClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_auth_read;
  struct_class->write = wfs_auth_write;

  gobject_class->finalize = wfs_auth_finalize;
  gobject_class->get_property = wfs_auth_get_property;
  gobject_class->set_property = wfs_auth_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_AUTH_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_AUTH_PWD,
     g_param_spec_string ("pwd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
wfs_auth_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsAuthClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_auth_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsAuth),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_auth_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsAuthType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsDataProperties
{
  PROP_WFS_DATA_0,
  PROP_WFS_DATA_DATA
};

/* reads a wfs_data object */
static gint32
wfs_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsData * this_object = WFS_DATA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsData * this_object = WFS_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsData", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_data == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->data ? ((GByteArray *) this_object->data)->data : NULL, this_object->data ? ((GByteArray *) this_object->data)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_data_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  WfsData *self = WFS_DATA (object);

  switch (property_id)
  {
    case PROP_WFS_DATA_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_data_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  WfsData *self = WFS_DATA (object);

  switch (property_id)
  {
    case PROP_WFS_DATA_DATA:
      g_value_set_boxed (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_data_instance_init (WfsData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->data = NULL;
  object->__isset_data = FALSE;
}

static void 
wfs_data_finalize (GObject *object)
{
  WfsData *tobject = WFS_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
}

static void
wfs_data_class_init (WfsDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_data_read;
  struct_class->write = wfs_data_write;

  gobject_class->finalize = wfs_data_finalize;
  gobject_class->get_property = wfs_data_get_property;
  gobject_class->set_property = wfs_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_DATA_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
wfs_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsData),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsFileProperties
{
  PROP_WFS_FILE_0,
  PROP_WFS_FILE_DATA,
  PROP_WFS_FILE_NAME,
  PROP_WFS_FILE_COMPRESS
};

/* reads a wfs_file object */
static gint32
wfs_file_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsFile * this_object = WFS_FILE(object);
  gboolean isset_data = FALSE;
  gboolean isset_name = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->data != NULL)
          {
            g_free(this_object->data);
            this_object->data = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data = g_byte_array_new();
          g_byte_array_append (this_object->data, (guint8 *) data, (guint) len);
          g_free (data);
          isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->compress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_data)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
wfs_file_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsFile * this_object = WFS_FILE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsFile", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->data ? ((GByteArray *) this_object->data)->data : NULL, this_object->data ? ((GByteArray *) this_object->data)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_compress == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "compress", T_BYTE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->compress, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_file_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  WfsFile *self = WFS_FILE (object);

  switch (property_id)
  {
    case PROP_WFS_FILE_DATA:
      if (self->data != NULL)
        g_byte_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      break;

    case PROP_WFS_FILE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      break;

    case PROP_WFS_FILE_COMPRESS:
      self->compress = g_value_get_int (value);
      self->__isset_compress = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_file_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  WfsFile *self = WFS_FILE (object);

  switch (property_id)
  {
    case PROP_WFS_FILE_DATA:
      g_value_set_boxed (value, self->data);
      break;

    case PROP_WFS_FILE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_WFS_FILE_COMPRESS:
      g_value_set_int (value, self->compress);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_file_instance_init (WfsFile * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->data = NULL;
  object->name = NULL;
  object->compress = 0;
  object->__isset_compress = FALSE;
}

static void 
wfs_file_finalize (GObject *object)
{
  WfsFile *tobject = WFS_FILE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data != NULL)
  {
    thrift_string_free(tobject->data);
    tobject->data = NULL;
  }
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
wfs_file_class_init (WfsFileClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_file_read;
  struct_class->write = wfs_file_write;

  gobject_class->finalize = wfs_file_finalize;
  gobject_class->get_property = wfs_file_get_property;
  gobject_class->set_property = wfs_file_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_FILE_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_FILE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_FILE_COMPRESS,
     g_param_spec_int ("compress",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
wfs_file_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsFileClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_file_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsFile),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_file_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsFileType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _WfsIfaceAppendArgsProperties
{
  PROP_WFS_IFACE_APPEND_ARGS_0,
  PROP_WFS_IFACE_APPEND_ARGS_FILE
};

/* reads a wfs_iface_append_args object */
static gint32
wfs_iface_append_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceAppendArgs * this_object = WFS_IFACE_APPEND_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->file), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_file = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_append_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceAppendArgs * this_object = WFS_IFACE_APPEND_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceAppendArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "file", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->file), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_append_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceAppendArgs *self = WFS_IFACE_APPEND_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_APPEND_ARGS_FILE:
      if (self->file != NULL)
        g_object_unref (self->file);
      self->file = g_value_dup_object (value);
      self->__isset_file = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_append_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceAppendArgs *self = WFS_IFACE_APPEND_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_APPEND_ARGS_FILE:
      g_value_set_object (value, self->file);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_append_args_instance_init (WfsIfaceAppendArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->file = g_object_new (TYPE_WFS_FILE, NULL);
  object->__isset_file = FALSE;
}

static void 
wfs_iface_append_args_finalize (GObject *object)
{
  WfsIfaceAppendArgs *tobject = WFS_IFACE_APPEND_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->file != NULL)
  {
    g_object_unref(tobject->file);
    tobject->file = NULL;
  }
}

static void
wfs_iface_append_args_class_init (WfsIfaceAppendArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_append_args_read;
  struct_class->write = wfs_iface_append_args_write;

  gobject_class->finalize = wfs_iface_append_args_finalize;
  gobject_class->get_property = wfs_iface_append_args_get_property;
  gobject_class->set_property = wfs_iface_append_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_APPEND_ARGS_FILE,
     g_param_spec_object ("file",
                         NULL,
                         NULL,
                         TYPE_WFS_FILE,
                         G_PARAM_READWRITE));
}

GType
wfs_iface_append_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceAppendArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_append_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceAppendArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_append_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceAppendArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceAppendResultProperties
{
  PROP_WFS_IFACE_APPEND_RESULT_0,
  PROP_WFS_IFACE_APPEND_RESULT_SUCCESS
};

/* reads a wfs_iface_append_result object */
static gint32
wfs_iface_append_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceAppendResult * this_object = WFS_IFACE_APPEND_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_append_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceAppendResult * this_object = WFS_IFACE_APPEND_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceAppendResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_append_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  WfsIfaceAppendResult *self = WFS_IFACE_APPEND_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_APPEND_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_append_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  WfsIfaceAppendResult *self = WFS_IFACE_APPEND_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_APPEND_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_append_result_instance_init (WfsIfaceAppendResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_ACK, NULL);
  object->__isset_success = FALSE;
}

static void 
wfs_iface_append_result_finalize (GObject *object)
{
  WfsIfaceAppendResult *tobject = WFS_IFACE_APPEND_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
wfs_iface_append_result_class_init (WfsIfaceAppendResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_append_result_read;
  struct_class->write = wfs_iface_append_result_write;

  gobject_class->finalize = wfs_iface_append_result_finalize;
  gobject_class->get_property = wfs_iface_append_result_get_property;
  gobject_class->set_property = wfs_iface_append_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_APPEND_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_ACK,
                         G_PARAM_READWRITE));
}

GType
wfs_iface_append_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceAppendResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_append_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceAppendResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_append_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceAppendResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceDeleteArgsProperties
{
  PROP_WFS_IFACE_DELETE_ARGS_0,
  PROP_WFS_IFACE_DELETE_ARGS_PATH
};

/* reads a wfs_iface_delete_args object */
static gint32
wfs_iface_delete_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceDeleteArgs * this_object = WFS_IFACE_DELETE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_delete_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceDeleteArgs * this_object = WFS_IFACE_DELETE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceDeleteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_delete_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceDeleteArgs *self = WFS_IFACE_DELETE_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_DELETE_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_delete_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceDeleteArgs *self = WFS_IFACE_DELETE_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_DELETE_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_delete_args_instance_init (WfsIfaceDeleteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
}

static void 
wfs_iface_delete_args_finalize (GObject *object)
{
  WfsIfaceDeleteArgs *tobject = WFS_IFACE_DELETE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
wfs_iface_delete_args_class_init (WfsIfaceDeleteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_delete_args_read;
  struct_class->write = wfs_iface_delete_args_write;

  gobject_class->finalize = wfs_iface_delete_args_finalize;
  gobject_class->get_property = wfs_iface_delete_args_get_property;
  gobject_class->set_property = wfs_iface_delete_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_DELETE_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
wfs_iface_delete_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceDeleteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_delete_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceDeleteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_delete_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceDeleteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceDeleteResultProperties
{
  PROP_WFS_IFACE_DELETE_RESULT_0,
  PROP_WFS_IFACE_DELETE_RESULT_SUCCESS
};

/* reads a wfs_iface_delete_result object */
static gint32
wfs_iface_delete_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceDeleteResult * this_object = WFS_IFACE_DELETE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_delete_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceDeleteResult * this_object = WFS_IFACE_DELETE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceDeleteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_delete_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  WfsIfaceDeleteResult *self = WFS_IFACE_DELETE_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_DELETE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_delete_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  WfsIfaceDeleteResult *self = WFS_IFACE_DELETE_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_DELETE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_delete_result_instance_init (WfsIfaceDeleteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_ACK, NULL);
  object->__isset_success = FALSE;
}

static void 
wfs_iface_delete_result_finalize (GObject *object)
{
  WfsIfaceDeleteResult *tobject = WFS_IFACE_DELETE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
wfs_iface_delete_result_class_init (WfsIfaceDeleteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_delete_result_read;
  struct_class->write = wfs_iface_delete_result_write;

  gobject_class->finalize = wfs_iface_delete_result_finalize;
  gobject_class->get_property = wfs_iface_delete_result_get_property;
  gobject_class->set_property = wfs_iface_delete_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_DELETE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_ACK,
                         G_PARAM_READWRITE));
}

GType
wfs_iface_delete_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceDeleteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_delete_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceDeleteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_delete_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceDeleteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceRenameArgsProperties
{
  PROP_WFS_IFACE_RENAME_ARGS_0,
  PROP_WFS_IFACE_RENAME_ARGS_PATH,
  PROP_WFS_IFACE_RENAME_ARGS_NEWPATH
};

/* reads a wfs_iface_rename_args object */
static gint32
wfs_iface_rename_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceRenameArgs * this_object = WFS_IFACE_RENAME_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->newpath != NULL)
          {
            g_free(this_object->newpath);
            this_object->newpath = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->newpath, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newpath = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_rename_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceRenameArgs * this_object = WFS_IFACE_RENAME_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceRenameArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newpath", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->newpath, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_rename_args_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceRenameArgs *self = WFS_IFACE_RENAME_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_RENAME_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    case PROP_WFS_IFACE_RENAME_ARGS_NEWPATH:
      if (self->newpath != NULL)
        g_free (self->newpath);
      self->newpath = g_value_dup_string (value);
      self->__isset_newpath = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_rename_args_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceRenameArgs *self = WFS_IFACE_RENAME_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_RENAME_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    case PROP_WFS_IFACE_RENAME_ARGS_NEWPATH:
      g_value_set_string (value, self->newpath);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_rename_args_instance_init (WfsIfaceRenameArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
  object->newpath = NULL;
  object->__isset_newpath = FALSE;
}

static void 
wfs_iface_rename_args_finalize (GObject *object)
{
  WfsIfaceRenameArgs *tobject = WFS_IFACE_RENAME_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
  if (tobject->newpath != NULL)
  {
    g_free(tobject->newpath);
    tobject->newpath = NULL;
  }
}

static void
wfs_iface_rename_args_class_init (WfsIfaceRenameArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_rename_args_read;
  struct_class->write = wfs_iface_rename_args_write;

  gobject_class->finalize = wfs_iface_rename_args_finalize;
  gobject_class->get_property = wfs_iface_rename_args_get_property;
  gobject_class->set_property = wfs_iface_rename_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_RENAME_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_RENAME_ARGS_NEWPATH,
     g_param_spec_string ("newpath",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
wfs_iface_rename_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceRenameArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_rename_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceRenameArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_rename_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceRenameArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceRenameResultProperties
{
  PROP_WFS_IFACE_RENAME_RESULT_0,
  PROP_WFS_IFACE_RENAME_RESULT_SUCCESS
};

/* reads a wfs_iface_rename_result object */
static gint32
wfs_iface_rename_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceRenameResult * this_object = WFS_IFACE_RENAME_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_rename_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceRenameResult * this_object = WFS_IFACE_RENAME_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceRenameResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_rename_result_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  WfsIfaceRenameResult *self = WFS_IFACE_RENAME_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_RENAME_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_rename_result_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  WfsIfaceRenameResult *self = WFS_IFACE_RENAME_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_RENAME_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_rename_result_instance_init (WfsIfaceRenameResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_ACK, NULL);
  object->__isset_success = FALSE;
}

static void 
wfs_iface_rename_result_finalize (GObject *object)
{
  WfsIfaceRenameResult *tobject = WFS_IFACE_RENAME_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
wfs_iface_rename_result_class_init (WfsIfaceRenameResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_rename_result_read;
  struct_class->write = wfs_iface_rename_result_write;

  gobject_class->finalize = wfs_iface_rename_result_finalize;
  gobject_class->get_property = wfs_iface_rename_result_get_property;
  gobject_class->set_property = wfs_iface_rename_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_RENAME_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_ACK,
                         G_PARAM_READWRITE));
}

GType
wfs_iface_rename_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceRenameResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_rename_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceRenameResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_rename_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceRenameResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceAuthArgsProperties
{
  PROP_WFS_IFACE_AUTH_ARGS_0,
  PROP_WFS_IFACE_AUTH_ARGS_WA
};

/* reads a wfs_iface_auth_args object */
static gint32
wfs_iface_auth_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceAuthArgs * this_object = WFS_IFACE_AUTH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->wa), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_wa = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_auth_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceAuthArgs * this_object = WFS_IFACE_AUTH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceAuthArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "wa", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->wa), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_auth_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  WfsIfaceAuthArgs *self = WFS_IFACE_AUTH_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_AUTH_ARGS_WA:
      if (self->wa != NULL)
        g_object_unref (self->wa);
      self->wa = g_value_dup_object (value);
      self->__isset_wa = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_auth_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  WfsIfaceAuthArgs *self = WFS_IFACE_AUTH_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_AUTH_ARGS_WA:
      g_value_set_object (value, self->wa);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_auth_args_instance_init (WfsIfaceAuthArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->wa = g_object_new (TYPE_WFS_AUTH, NULL);
  object->__isset_wa = FALSE;
}

static void 
wfs_iface_auth_args_finalize (GObject *object)
{
  WfsIfaceAuthArgs *tobject = WFS_IFACE_AUTH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->wa != NULL)
  {
    g_object_unref(tobject->wa);
    tobject->wa = NULL;
  }
}

static void
wfs_iface_auth_args_class_init (WfsIfaceAuthArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_auth_args_read;
  struct_class->write = wfs_iface_auth_args_write;

  gobject_class->finalize = wfs_iface_auth_args_finalize;
  gobject_class->get_property = wfs_iface_auth_args_get_property;
  gobject_class->set_property = wfs_iface_auth_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_AUTH_ARGS_WA,
     g_param_spec_object ("wa",
                         NULL,
                         NULL,
                         TYPE_WFS_AUTH,
                         G_PARAM_READWRITE));
}

GType
wfs_iface_auth_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceAuthArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_auth_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceAuthArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_auth_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceAuthArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceAuthResultProperties
{
  PROP_WFS_IFACE_AUTH_RESULT_0,
  PROP_WFS_IFACE_AUTH_RESULT_SUCCESS
};

/* reads a wfs_iface_auth_result object */
static gint32
wfs_iface_auth_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceAuthResult * this_object = WFS_IFACE_AUTH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_auth_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceAuthResult * this_object = WFS_IFACE_AUTH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceAuthResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_auth_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceAuthResult *self = WFS_IFACE_AUTH_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_AUTH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_auth_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfaceAuthResult *self = WFS_IFACE_AUTH_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_AUTH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_auth_result_instance_init (WfsIfaceAuthResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_ACK, NULL);
  object->__isset_success = FALSE;
}

static void 
wfs_iface_auth_result_finalize (GObject *object)
{
  WfsIfaceAuthResult *tobject = WFS_IFACE_AUTH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
wfs_iface_auth_result_class_init (WfsIfaceAuthResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_auth_result_read;
  struct_class->write = wfs_iface_auth_result_write;

  gobject_class->finalize = wfs_iface_auth_result_finalize;
  gobject_class->get_property = wfs_iface_auth_result_get_property;
  gobject_class->set_property = wfs_iface_auth_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_AUTH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_ACK,
                         G_PARAM_READWRITE));
}

GType
wfs_iface_auth_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceAuthResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_auth_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceAuthResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_auth_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceAuthResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceGetArgsProperties
{
  PROP_WFS_IFACE_GET_ARGS_0,
  PROP_WFS_IFACE_GET_ARGS_PATH
};

/* reads a wfs_iface_get_args object */
static gint32
wfs_iface_get_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceGetArgs * this_object = WFS_IFACE_GET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->path != NULL)
          {
            g_free(this_object->path);
            this_object->path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_get_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceGetArgs * this_object = WFS_IFACE_GET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceGetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->path, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_get_args_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  WfsIfaceGetArgs *self = WFS_IFACE_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_GET_ARGS_PATH:
      if (self->path != NULL)
        g_free (self->path);
      self->path = g_value_dup_string (value);
      self->__isset_path = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_get_args_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  WfsIfaceGetArgs *self = WFS_IFACE_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_GET_ARGS_PATH:
      g_value_set_string (value, self->path);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_get_args_instance_init (WfsIfaceGetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path = NULL;
  object->__isset_path = FALSE;
}

static void 
wfs_iface_get_args_finalize (GObject *object)
{
  WfsIfaceGetArgs *tobject = WFS_IFACE_GET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path != NULL)
  {
    g_free(tobject->path);
    tobject->path = NULL;
  }
}

static void
wfs_iface_get_args_class_init (WfsIfaceGetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_get_args_read;
  struct_class->write = wfs_iface_get_args_write;

  gobject_class->finalize = wfs_iface_get_args_finalize;
  gobject_class->get_property = wfs_iface_get_args_get_property;
  gobject_class->set_property = wfs_iface_get_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_GET_ARGS_PATH,
     g_param_spec_string ("path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
wfs_iface_get_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceGetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_get_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceGetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_get_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceGetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfaceGetResultProperties
{
  PROP_WFS_IFACE_GET_RESULT_0,
  PROP_WFS_IFACE_GET_RESULT_SUCCESS
};

/* reads a wfs_iface_get_result object */
static gint32
wfs_iface_get_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfaceGetResult * this_object = WFS_IFACE_GET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_get_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfaceGetResult * this_object = WFS_IFACE_GET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfaceGetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_get_result_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  WfsIfaceGetResult *self = WFS_IFACE_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_GET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_get_result_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  WfsIfaceGetResult *self = WFS_IFACE_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_GET_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_get_result_instance_init (WfsIfaceGetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_DATA, NULL);
  object->__isset_success = FALSE;
}

static void 
wfs_iface_get_result_finalize (GObject *object)
{
  WfsIfaceGetResult *tobject = WFS_IFACE_GET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
wfs_iface_get_result_class_init (WfsIfaceGetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_get_result_read;
  struct_class->write = wfs_iface_get_result_write;

  gobject_class->finalize = wfs_iface_get_result_finalize;
  gobject_class->get_property = wfs_iface_get_result_get_property;
  gobject_class->set_property = wfs_iface_get_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_GET_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_DATA,
                         G_PARAM_READWRITE));
}

GType
wfs_iface_get_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfaceGetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_get_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfaceGetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_get_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfaceGetResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a wfs_iface_ping_args object */
static gint32
wfs_iface_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfacePingArgs * this_object = WFS_IFACE_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfacePingArgs * this_object = WFS_IFACE_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfacePingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
wfs_iface_ping_args_instance_init (WfsIfacePingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
wfs_iface_ping_args_finalize (GObject *object)
{
  WfsIfacePingArgs *tobject = WFS_IFACE_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
wfs_iface_ping_args_class_init (WfsIfacePingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_ping_args_read;
  struct_class->write = wfs_iface_ping_args_write;

  gobject_class->finalize = wfs_iface_ping_args_finalize;
}

GType
wfs_iface_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfacePingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfacePingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfacePingArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsIfacePingResultProperties
{
  PROP_WFS_IFACE_PING_RESULT_0,
  PROP_WFS_IFACE_PING_RESULT_SUCCESS
};

/* reads a wfs_iface_ping_result object */
static gint32
wfs_iface_ping_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsIfacePingResult * this_object = WFS_IFACE_PING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_iface_ping_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsIfacePingResult * this_object = WFS_IFACE_PING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsIfacePingResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BYTE, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_iface_ping_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfacePingResult *self = WFS_IFACE_PING_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_PING_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_iface_ping_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  WfsIfacePingResult *self = WFS_IFACE_PING_RESULT (object);

  switch (property_id)
  {
    case PROP_WFS_IFACE_PING_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_iface_ping_result_instance_init (WfsIfacePingResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
wfs_iface_ping_result_finalize (GObject *object)
{
  WfsIfacePingResult *tobject = WFS_IFACE_PING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
wfs_iface_ping_result_class_init (WfsIfacePingResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_iface_ping_result_read;
  struct_class->write = wfs_iface_ping_result_write;

  gobject_class->finalize = wfs_iface_ping_result_finalize;
  gobject_class->get_property = wfs_iface_ping_result_get_property;
  gobject_class->set_property = wfs_iface_ping_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_IFACE_PING_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
wfs_iface_ping_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsIfacePingResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_iface_ping_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsIfacePingResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_iface_ping_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsIfacePingResultType",
                                   &type_info, 0);
  }

  return type;
}

