/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "wfs_types.h"
#include <thrift/c_glib/thrift.h>

enum _WfsAckProperties
{
  PROP_WFS_ACK_0,
  PROP_WFS_ACK_STATUS
};

/* reads a wfs_ack object */
static gint32
wfs_ack_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsAck * this_object = WFS_ACK(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->status, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_status = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_ack_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsAck * this_object = WFS_ACK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsAck", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_status == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "status", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->status, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_ack_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  WfsAck *self = WFS_ACK (object);

  switch (property_id)
  {
    case PROP_WFS_ACK_STATUS:
      self->status = g_value_get_int (value);
      self->__isset_status = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_ack_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  WfsAck *self = WFS_ACK (object);

  switch (property_id)
  {
    case PROP_WFS_ACK_STATUS:
      g_value_set_int (value, self->status);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_ack_instance_init (WfsAck * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->status = 0;
  object->__isset_status = FALSE;
}

static void 
wfs_ack_finalize (GObject *object)
{
  WfsAck *tobject = WFS_ACK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
wfs_ack_class_init (WfsAckClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_ack_read;
  struct_class->write = wfs_ack_write;

  gobject_class->finalize = wfs_ack_finalize;
  gobject_class->get_property = wfs_ack_get_property;
  gobject_class->set_property = wfs_ack_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_ACK_STATUS,
     g_param_spec_int ("status",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
wfs_ack_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsAckClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_ack_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsAck),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_ack_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsAckType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsProperties
{
  PROP_WFS_0,
  PROP_WFS_STATUS
};

/* reads a wfs object */
static gint32
wfs_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Wfs * this_object = WFS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->status, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_status = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Wfs * this_object = WFS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Wfs", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_status == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "status", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->status, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_set_property (GObject *object,
                  guint property_id,
                  const GValue *value,
                  GParamSpec *pspec)
{
  Wfs *self = WFS (object);

  switch (property_id)
  {
    case PROP_WFS_STATUS:
      self->status = g_value_get_int (value);
      self->__isset_status = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_get_property (GObject *object,
                  guint property_id,
                  GValue *value,
                  GParamSpec *pspec)
{
  Wfs *self = WFS (object);

  switch (property_id)
  {
    case PROP_WFS_STATUS:
      g_value_set_int (value, self->status);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_instance_init (Wfs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->status = 0;
  object->__isset_status = FALSE;
}

static void 
wfs_finalize (GObject *object)
{
  Wfs *tobject = WFS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
wfs_class_init (WfsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_read;
  struct_class->write = wfs_write;

  gobject_class->finalize = wfs_finalize;
  gobject_class->get_property = wfs_get_property;
  gobject_class->set_property = wfs_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_STATUS,
     g_param_spec_int ("status",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
wfs_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Wfs),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsType",
                                   &type_info, 0);
  }

  return type;
}

enum _WfsFileProperties
{
  PROP_WFS_FILE_0,
  PROP_WFS_FILE_NAME,
  PROP_WFS_FILE_FILE_BODY,
  PROP_WFS_FILE_FILE_TYPE
};

/* reads a wfs_file object */
static gint32
wfs_file_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  WfsFile * this_object = WFS_FILE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->fileBody != NULL)
          {
            g_free(this_object->fileBody);
            this_object->fileBody = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->fileBody = g_byte_array_new();
          g_byte_array_append (this_object->fileBody, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_fileBody = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->fileType != NULL)
          {
            g_free(this_object->fileType);
            this_object->fileType = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->fileType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fileType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
wfs_file_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  WfsFile * this_object = WFS_FILE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "WfsFile", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_fileBody == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fileBody", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, ((GByteArray *) this_object->fileBody)->data, ((GByteArray *) this_object->fileBody)->len, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_fileType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fileType", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->fileType, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
wfs_file_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  WfsFile *self = WFS_FILE (object);

  switch (property_id)
  {
    case PROP_WFS_FILE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_WFS_FILE_FILE_BODY:
      if (self->fileBody != NULL)
        g_byte_array_unref (self->fileBody);
      self->fileBody = g_value_dup_boxed (value);
      self->__isset_fileBody = TRUE;
      break;

    case PROP_WFS_FILE_FILE_TYPE:
      if (self->fileType != NULL)
        g_free (self->fileType);
      self->fileType = g_value_dup_string (value);
      self->__isset_fileType = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
wfs_file_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  WfsFile *self = WFS_FILE (object);

  switch (property_id)
  {
    case PROP_WFS_FILE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_WFS_FILE_FILE_BODY:
      g_value_set_boxed (value, self->fileBody);
      break;

    case PROP_WFS_FILE_FILE_TYPE:
      g_value_set_string (value, self->fileType);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
wfs_file_instance_init (WfsFile * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->fileBody = NULL;
  object->__isset_fileBody = FALSE;
  object->fileType = NULL;
  object->__isset_fileType = FALSE;
}

static void 
wfs_file_finalize (GObject *object)
{
  WfsFile *tobject = WFS_FILE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->fileBody != NULL)
  {
    thrift_string_free(tobject->fileBody);
    tobject->fileBody = NULL;
  }
  if (tobject->fileType != NULL)
  {
    g_free(tobject->fileType);
    tobject->fileType = NULL;
  }
}

static void
wfs_file_class_init (WfsFileClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = wfs_file_read;
  struct_class->write = wfs_file_write;

  gobject_class->finalize = wfs_file_finalize;
  gobject_class->get_property = wfs_file_get_property;
  gobject_class->set_property = wfs_file_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_FILE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_FILE_FILE_BODY,
     g_param_spec_boxed ("fileBody",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_WFS_FILE_FILE_TYPE,
     g_param_spec_string ("fileType",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
wfs_file_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (WfsFileClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) wfs_file_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (WfsFile),
      0, /* n_preallocs */
      (GInstanceInitFunc) wfs_file_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "WfsFileType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _IWfsWfsPostArgsProperties
{
  PROP_I_WFS_WFS_POST_ARGS_0,
  PROP_I_WFS_WFS_POST_ARGS_WF
};

/* reads a i_wfs_wfs_post_args object */
static gint32
i_wfs_wfs_post_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IWfsWfsPostArgs * this_object = I_WFS_WFS_POST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->wf), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_wf = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_wfs_wfs_post_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IWfsWfsPostArgs * this_object = I_WFS_WFS_POST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IWfsWfsPostArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "wf", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->wf), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_wfs_wfs_post_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  IWfsWfsPostArgs *self = I_WFS_WFS_POST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_POST_ARGS_WF:
      if (self->wf != NULL)
        g_object_unref (self->wf);
      self->wf = g_value_dup_object (value);
      self->__isset_wf = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_wfs_wfs_post_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  IWfsWfsPostArgs *self = I_WFS_WFS_POST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_POST_ARGS_WF:
      g_value_set_object (value, self->wf);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_wfs_wfs_post_args_instance_init (IWfsWfsPostArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->wf = g_object_new (TYPE_WFS_FILE, NULL);
  object->__isset_wf = FALSE;
}

static void 
i_wfs_wfs_post_args_finalize (GObject *object)
{
  IWfsWfsPostArgs *tobject = I_WFS_WFS_POST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->wf != NULL)
  {
    g_object_unref(tobject->wf);
    tobject->wf = NULL;
  }
}

static void
i_wfs_wfs_post_args_class_init (IWfsWfsPostArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_wfs_wfs_post_args_read;
  struct_class->write = i_wfs_wfs_post_args_write;

  gobject_class->finalize = i_wfs_wfs_post_args_finalize;
  gobject_class->get_property = i_wfs_wfs_post_args_get_property;
  gobject_class->set_property = i_wfs_wfs_post_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_WFS_WFS_POST_ARGS_WF,
     g_param_spec_object ("wf",
                         NULL,
                         NULL,
                         TYPE_WFS_FILE,
                         G_PARAM_READWRITE));
}

GType
i_wfs_wfs_post_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IWfsWfsPostArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_wfs_wfs_post_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IWfsWfsPostArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_wfs_wfs_post_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IWfsWfsPostArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IWfsWfsPostResultProperties
{
  PROP_I_WFS_WFS_POST_RESULT_0,
  PROP_I_WFS_WFS_POST_RESULT_SUCCESS
};

/* reads a i_wfs_wfs_post_result object */
static gint32
i_wfs_wfs_post_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IWfsWfsPostResult * this_object = I_WFS_WFS_POST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_wfs_wfs_post_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IWfsWfsPostResult * this_object = I_WFS_WFS_POST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IWfsWfsPostResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_wfs_wfs_post_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  IWfsWfsPostResult *self = I_WFS_WFS_POST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_POST_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_wfs_wfs_post_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  IWfsWfsPostResult *self = I_WFS_WFS_POST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_POST_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_wfs_wfs_post_result_instance_init (IWfsWfsPostResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_ACK, NULL);
  object->__isset_success = FALSE;
}

static void 
i_wfs_wfs_post_result_finalize (GObject *object)
{
  IWfsWfsPostResult *tobject = I_WFS_WFS_POST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_wfs_wfs_post_result_class_init (IWfsWfsPostResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_wfs_wfs_post_result_read;
  struct_class->write = i_wfs_wfs_post_result_write;

  gobject_class->finalize = i_wfs_wfs_post_result_finalize;
  gobject_class->get_property = i_wfs_wfs_post_result_get_property;
  gobject_class->set_property = i_wfs_wfs_post_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_WFS_WFS_POST_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_ACK,
                         G_PARAM_READWRITE));
}

GType
i_wfs_wfs_post_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IWfsWfsPostResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_wfs_wfs_post_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IWfsWfsPostResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_wfs_wfs_post_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IWfsWfsPostResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IWfsWfsReadArgsProperties
{
  PROP_I_WFS_WFS_READ_ARGS_0,
  PROP_I_WFS_WFS_READ_ARGS_NAME
};

/* reads a i_wfs_wfs_read_args object */
static gint32
i_wfs_wfs_read_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IWfsWfsReadArgs * this_object = I_WFS_WFS_READ_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_wfs_wfs_read_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IWfsWfsReadArgs * this_object = I_WFS_WFS_READ_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IWfsWfsReadArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_wfs_wfs_read_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  IWfsWfsReadArgs *self = I_WFS_WFS_READ_ARGS (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_READ_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_wfs_wfs_read_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  IWfsWfsReadArgs *self = I_WFS_WFS_READ_ARGS (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_READ_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_wfs_wfs_read_args_instance_init (IWfsWfsReadArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
}

static void 
i_wfs_wfs_read_args_finalize (GObject *object)
{
  IWfsWfsReadArgs *tobject = I_WFS_WFS_READ_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
i_wfs_wfs_read_args_class_init (IWfsWfsReadArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_wfs_wfs_read_args_read;
  struct_class->write = i_wfs_wfs_read_args_write;

  gobject_class->finalize = i_wfs_wfs_read_args_finalize;
  gobject_class->get_property = i_wfs_wfs_read_args_get_property;
  gobject_class->set_property = i_wfs_wfs_read_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_WFS_WFS_READ_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_wfs_wfs_read_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IWfsWfsReadArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_wfs_wfs_read_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IWfsWfsReadArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_wfs_wfs_read_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IWfsWfsReadArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IWfsWfsReadResultProperties
{
  PROP_I_WFS_WFS_READ_RESULT_0,
  PROP_I_WFS_WFS_READ_RESULT_SUCCESS
};

/* reads a i_wfs_wfs_read_result object */
static gint32
i_wfs_wfs_read_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IWfsWfsReadResult * this_object = I_WFS_WFS_READ_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_wfs_wfs_read_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IWfsWfsReadResult * this_object = I_WFS_WFS_READ_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IWfsWfsReadResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_wfs_wfs_read_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  IWfsWfsReadResult *self = I_WFS_WFS_READ_RESULT (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_READ_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_wfs_wfs_read_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  IWfsWfsReadResult *self = I_WFS_WFS_READ_RESULT (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_READ_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_wfs_wfs_read_result_instance_init (IWfsWfsReadResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_FILE, NULL);
  object->__isset_success = FALSE;
}

static void 
i_wfs_wfs_read_result_finalize (GObject *object)
{
  IWfsWfsReadResult *tobject = I_WFS_WFS_READ_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_wfs_wfs_read_result_class_init (IWfsWfsReadResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_wfs_wfs_read_result_read;
  struct_class->write = i_wfs_wfs_read_result_write;

  gobject_class->finalize = i_wfs_wfs_read_result_finalize;
  gobject_class->get_property = i_wfs_wfs_read_result_get_property;
  gobject_class->set_property = i_wfs_wfs_read_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_WFS_WFS_READ_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_FILE,
                         G_PARAM_READWRITE));
}

GType
i_wfs_wfs_read_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IWfsWfsReadResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_wfs_wfs_read_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IWfsWfsReadResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_wfs_wfs_read_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IWfsWfsReadResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IWfsWfsDelArgsProperties
{
  PROP_I_WFS_WFS_DEL_ARGS_0,
  PROP_I_WFS_WFS_DEL_ARGS_NAME
};

/* reads a i_wfs_wfs_del_args object */
static gint32
i_wfs_wfs_del_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IWfsWfsDelArgs * this_object = I_WFS_WFS_DEL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_wfs_wfs_del_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IWfsWfsDelArgs * this_object = I_WFS_WFS_DEL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IWfsWfsDelArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_wfs_wfs_del_args_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  IWfsWfsDelArgs *self = I_WFS_WFS_DEL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_DEL_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_wfs_wfs_del_args_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  IWfsWfsDelArgs *self = I_WFS_WFS_DEL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_DEL_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_wfs_wfs_del_args_instance_init (IWfsWfsDelArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
}

static void 
i_wfs_wfs_del_args_finalize (GObject *object)
{
  IWfsWfsDelArgs *tobject = I_WFS_WFS_DEL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
i_wfs_wfs_del_args_class_init (IWfsWfsDelArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_wfs_wfs_del_args_read;
  struct_class->write = i_wfs_wfs_del_args_write;

  gobject_class->finalize = i_wfs_wfs_del_args_finalize;
  gobject_class->get_property = i_wfs_wfs_del_args_get_property;
  gobject_class->set_property = i_wfs_wfs_del_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_WFS_WFS_DEL_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_wfs_wfs_del_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IWfsWfsDelArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_wfs_wfs_del_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IWfsWfsDelArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_wfs_wfs_del_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IWfsWfsDelArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IWfsWfsDelResultProperties
{
  PROP_I_WFS_WFS_DEL_RESULT_0,
  PROP_I_WFS_WFS_DEL_RESULT_SUCCESS
};

/* reads a i_wfs_wfs_del_result object */
static gint32
i_wfs_wfs_del_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IWfsWfsDelResult * this_object = I_WFS_WFS_DEL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_wfs_wfs_del_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IWfsWfsDelResult * this_object = I_WFS_WFS_DEL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IWfsWfsDelResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_wfs_wfs_del_result_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  IWfsWfsDelResult *self = I_WFS_WFS_DEL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_DEL_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_wfs_wfs_del_result_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  IWfsWfsDelResult *self = I_WFS_WFS_DEL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_WFS_WFS_DEL_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_wfs_wfs_del_result_instance_init (IWfsWfsDelResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_WFS_ACK, NULL);
  object->__isset_success = FALSE;
}

static void 
i_wfs_wfs_del_result_finalize (GObject *object)
{
  IWfsWfsDelResult *tobject = I_WFS_WFS_DEL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
i_wfs_wfs_del_result_class_init (IWfsWfsDelResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_wfs_wfs_del_result_read;
  struct_class->write = i_wfs_wfs_del_result_write;

  gobject_class->finalize = i_wfs_wfs_del_result_finalize;
  gobject_class->get_property = i_wfs_wfs_del_result_get_property;
  gobject_class->set_property = i_wfs_wfs_del_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_WFS_WFS_DEL_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_WFS_ACK,
                         G_PARAM_READWRITE));
}

GType
i_wfs_wfs_del_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IWfsWfsDelResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_wfs_wfs_del_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IWfsWfsDelResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_wfs_wfs_del_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IWfsWfsDelResultType",
                                   &type_info, 0);
  }

  return type;
}

